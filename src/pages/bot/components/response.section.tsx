import moment from "moment";
import { useEffect, useState } from "react";
import { MdClose, MdSearch, MdTerminal } from "react-icons/md";
import {
  TbMailAi,
  TbMailCheck,
  TbReportAnalytics,
  TbReportSearch,
} from "react-icons/tb";

import {
  BotPromptView,
  PromptInputView,
} from "src/components/ui/windows_views";
import EmailView from "src/components/ui/windows_views/email.view";
import ReportsView from "src/components/ui/windows_views/reports.view";
import TerminateView from "src/components/ui/windows_views/terminatView";
import { ResponseData } from "src/contexts";

interface TextResponseViewProps {
  response: ResponseData;
  allResponses?: ResponseData[];
  defaultOpen?: boolean;
  animate?: boolean;
  submitAdminPromptResponse?: (id: string | number, data: string) => void;
}
const TextResponseView = ({
  response,
  defaultOpen = false,
  submitAdminPromptResponse,
  allResponses,
}: TextResponseViewProps) => {
  const [_, setIsOpen] = useState(defaultOpen);
  const time = moment(response?.timestamp || Date.now()).fromNow();
  const handleSubmitPrompt = (data: string) => {
    if (submitAdminPromptResponse) {
      submitAdminPromptResponse(response?.id, data);
    }
  };

  const icons: Record<
    Exclude<ResponseData["response_type"], undefined>,
    { icon: React.ReactNode; color: string }
  > = {
    email: { icon: <TbMailAi />, color: "text-yellow-500 bg-yellow-500/20" },
    report: {
      icon: <TbReportAnalytics />,
      color: "text-blue-500 bg-blue-500/20",
    },
    final_email: {
      icon: <TbMailCheck />,
      color: "text-green-500 bg-green-500/20",
    },
    terminated: { icon: <MdClose />, color: "text-red-500 bg-red-500/20" },
    research_report: {
      icon: <TbReportSearch />,
      color: "text-violet-500 bg-violet-500/20",
    },
    search_parameters: {
      icon: <MdSearch />,
      color: "text-pink-500 bg-pink-500/20",
    },
    prompt: { icon: <MdTerminal />, color: "text-indigo-500 bg-indigo-500/20" },
  };

  useEffect(() => {
    setIsOpen(defaultOpen);
  }, [defaultOpen]);

  if (
    response?.response_type === "prompt" &&
    response?.requested_to === "admin"
  ) {
    return (
      <PromptInputView
        onSubmitPrompt={handleSubmitPrompt}
        title={response.content || ""}
      />
    );
  }
  if (
    response?.response_type === "prompt" &&
    response?.requested_to === "bot"
  ) {
    return (
      <BotPromptView
        content={response?.content || ""}
        timestamp={response?.timestamp}
      />
    );
  }

  if (response?.response_type === "terminated") {
    const { content, timestamp, agent } =
      (allResponses?.find(
        (item) => item?.response_type === "final_email"
      ) as ResponseData) || {};
    const subject = content?.match(/Subject:\s*(.*)/)?.[1];
    const emailTime = moment(timestamp || Date.now()).fromNow();

    return (
      <>
        <TerminateView
          message={`Email **"Subject: ${subject}"** has been generated by **${agent}** at **${emailTime}** and process has been terminated by **${
            response?.agent === agent ? "admin" : response?.agent
          }** at **${time}**`}
        />
        <div className="flex items-center gap-2">
          <span>----------------</span>
          <p>Completed and closed</p>
          <span>----------------</span>
        </div>
      </>
    );
  }

  if (response?.response_type === "final_email") {
    return (
      <EmailView
        id={response?.id}
        time={time}
        timeline={allResponses}
        content={response?.content || ""}
        open
        showControls
        headingText={response?.response_type + " (" + response?.agent + ")"}
        iconColor={icons[response?.response_type]?.color}
      />
    );
  }

  return (
    <>
      <ReportsView
        content={response?.content || ""}
        headingText={response?.response_type + " (" + response?.agent + ")"}
        icon={icons[response?.response_type]?.icon}
        iconColor={icons[response?.response_type]?.color}
        time={time}
        showControls
      />
    </>
  );
};

export default TextResponseView;
